#!/usr/bin/env python3

'''Copy a playlist while retaining the directory hierarchy - v0.3.1 '''

#TODO:
#-Autogenerate playlist based on ratings from gmusicbrowser config file
#-Allow transfering a folder full of playlists
#-Allow option to transfer playlist with the songs
#-Convert playlists from windows to unix, old library to new, etc.
#-Split verbose output and log output options so you can do one or other

import os, shutil, sys, urllib.parse

class NotSupportedError(ValueError): pass

class Settings():
	'''Class used for keeping default settings'''
	path = ''
	player_lib = ''
	verbose = False
	music_lib = ''
	copy_dst = ''
	autogen_pl = ''	# Autogen playlist path
	r_cutoff = 0	# Rating threshold for autogenerating list
	
	def __init__(self, settings_path):
		self.path = settings_path
		self.load()
	
	def save(self):
		with open(self.path, mode='w', encoding='utf-8') as settings:
			settings.write('lib={}\n'.format(self.music_lib))
			settings.write('dst={}\n'.format(self.copy_dst))
			settings.write('gen_lib={}\n'.format(self.player_lib))
			settings.write('gen_dst={}\n'.format(self.autogen_pl))
			settings.write('r={}\n'.format(str(self.r_cutoff)))
		
	def load(self):
		try:
			with open(self.path, 'r', encoding='utf-8') as settings:
				for line in settings:
					self.parse(line.rstrip())
		except FileNotFoundError:
			pass
		
	def parse(self, setting):
		if setting[:4] == 'lib=':
			self.music_lib = setting[4:]
		elif setting[:4] == 'dst=':
			self.copy_dst = setting[4:]
		elif setting[:8] == 'gen_lib=':
			self.player_lib = setting[8:]
		elif setting[:8] == 'gen_dst=':
			self.autogen_pl = setting[8:]
		elif setting[:2] == 'r=':
			self.r_cutoff = int(setting[2:])
	
	def set_defaults(self):
		print('Setting defaults, '+
			'leave blank if manual input preferred...')
		self.copy_dst = input('Default transfer destination:')
		self.music_lib = input('Path to music library:')
		self.player_lib = input('Path to gmusicbrowser config file:')
		self.autogen_pl = input('Autogenerated playlist destination:')
		self.r_cutoff = input('Default rating cutoff?')
		self.save()

accepted_file_types = [".m3u", '.m3u8']
help_dialog = '''PlaylistExport - Utility for transfering playlists
Usage: [lib=/path/to/music/library] [dst=/path/to/destination] /play/list.m3u

Description: Transfer a playlist while maintaining the file hierarchy
found in the music library folder (or from wherever they are being
transfered).

Flags:
-h - display this dialog and exit
-v - run in verbose mode
-a - autogenerate a playlist from music player settings (gmusicbrowser)
-d - launch prompt to set default settings

Variables:
dst= - destination for copying playlist files to
lib= - path to music library (of the files in destination playlist)
gen_lib= - path to music player library settings (gmusicbrowser only)
gen_dst= - pestination for output of autogenerated playlist
r= - rating cutoff, songs < than rating do not get autogenerated

Accepted File Types: .m3u, .m3u8

Note: order of arguments does not matter.
'''

def is_accepted_playlist(filename):
	'''Make sure that playlists are an accepted file type.'''
	for t in accepted_file_types:
		if t == os.path.splitext(filename)[1]:
			return True
	return False

def report(filepath, m, verbose=True):
	'''Write to both a log file and the stdout'''
	if verbose:
		# Only write if reporting is turned on
		print(m)
		with open(filepath, "a") as l:
			l.write(m)
			l.write("\n") 	# This way we can write more than strings

def load(listpath):
	'''Load the file paths of a playlist into memory'''
	playlist = []
	
	#Check for any exceptions to be handled
	if not os.path.exists(listpath):
		raise FileNotFoundError("Playlist file not found.")
	
	if not is_accepted_playlist(listpath):
		raise NotSupportedError("File type not supported.")
	
	with open(listpath, "r", encoding="utf-8") as f: # loads a .m3u file
		for path in f:
			if path[0] == "#" or path[0] == '\n':
				continue	# Ignore comments and white space
			playlist.append(path.rstrip())	#Get rid of \n on paths
	
	return playlist

def fetch_lib(config_dir):
	'''Fetch music library data (gmusicbrowser only so far)'''
	songs = []				#All data about songs from config gmb
	songs_reached = False	#Bool to check when we reach  [songs]
	gmb_data_seq = (		#Order that gmb song list is tabbed
		'index',			#To be zip()'d into a dictionary w/results
		'added',
		'album',
		'album_artist_raw',
		'artist',	
		'bitrate',	
		'channel',
		'comment',	
		'compilation',	
		'disc',
		'file',
		'filetype',
		'genre',	
		'grouping',
		'label',
		'lastplay',
		'lastskip',	
		'length',
		'length_estimated',
		'missing',
		'modif',
		'path',
		'playcount',
		'playhistory',	
		'rating',
		'replaygain_album_gain',
		'replaygain_album_peak',
		'replaygain_track_gain',	
		'replaygain_track_peak',
		'samprate',
		'size',
		'skipcount',
		'title',	
		'track',
		'version',
		'year'
	)
	
	#Check for any exceptions to be handled
	if not os.path.exists(config_dir):
		raise FileNotFoundError("GMusicbrowser config file not found.")
		
	with open(config_dir, 'r', encoding='utf-8') as conf:
		# For parsing a gmusicbrowser library
		for entry in conf:
			if entry.rstrip() == '[album]':	
				songs.pop() #last entry is garbage
				break	# Break once we're out of [Songs]
			if entry.rstrip() == '[Songs]':
				songs_reached = True
				continue
			if songs_reached == False:
				continue
			elif songs_reached == True:
				tabbed_list = entry.rstrip().split('\t')
				if tabbed_list[0] == "added" or tabbed_list[0] == '':
					#skip any lines that aren't an entry
					continue 
				else:
					song = dict(zip(gmb_data_seq, tabbed_list))
					song['path'] = urllib.parse.unquote(song['path'])
					song['file'] = urllib.parse.unquote(song['file'])
					songs.append(song)
	
	return songs
				
def generate_playlist(songs_list, destination, rating=0):
	'''Generate a playlist based on music library data'''
	
	with open(destination, 'w', encoding='utf-8') as f:
		f.write('#EXTM3U\n\n')	# Heading for an m3u file
		for song in songs_list:
			if song['rating'] == '':
				song['rating'] = 0	# '' is invalid for int()
			if int(song['rating']) > rating: 
				f.write('#EXTINF:{},{} - {}\n'.format(song['length'],
					song['artist'], song['title']))
				f.write('{}\n'.format(os.path.join(
					song['path'], song['file'])))
	f.close()

def export(playlist, dst_root, src_root='', verbose=False):
	'''Export playlist file paths while maintaining dir hierarchy'''
	
	for list_index, path in enumerate(playlist):
		if src_root != path[:len(src_root)]:
			# If the file paths are not absolute then assume relative
			path = os.path.join(src_root, path)
		filename = os.path.basename(path)  # Seperate filename from path
		# add 1 to len(src_root) so if src_root is '' it still works
		dst_dirs = os.path.join(dst_root, 
			path[len(src_root)+1:-len(filename)])
		full_dst = os.path.join(dst_dirs, filename)
		export_log = "playlistexport.log"
		
		if verbose == True:
			os.system('cls' if os.name == 'nt' else 'clear')
		
		report(export_log, "{0} of {1} songs..."
		.format(list_index+1, len(playlist)), verbose)
		
		if not os.path.exists(dst_dirs):
			report(export_log, "Making directory {0}..."
				.format(dst_dirs), verbose)
			os.makedirs(dst_dirs)
		if not os.path.exists(full_dst):
			try:
				report(export_log, "Copying {0}...".format(filename),
					verbose)
				shutil.copy(path, full_dst)
			except FileNotFoundError:
				report(export_log, "Skipping {0}, does not exist!"
					.format(filename), verbose)

if __name__ == "__main__":
	playlists = []
	config = Settings('settings')
	auto_gen = False
	verbose = False
	error_log = "error.log"
	
	if len(sys.argv) > 1:	# If there are args, read them.
		for a in sys.argv:
			if a[0] == "-":
				for flag in a:
					if flag == 'h':
						print(help_dialog)
						exit()
					if flag == 'v':
						verbose = True
					if flag == 'a':
						auto_gen = True
					if flag == 'd':
						config.set_defaults()
						exit()
			if is_accepted_playlist(a):
				playlists.append(a)
			config.parse(a)
	else:	# Prompt the user directly for files
		print("Must use absolute file paths, do not end with / or \\.")
		while True:
			# Get rid of ' from drag n drop to terminal, revise later
			# So ' in the middle of a path can be passed
			if os.path.exists(config.copy_dst):
				print('Destination: {}'.format(config.copy_dst))
				if input('Use default? [Y/N]').upper() == 'Y':
					break
			config.copy_dst = input("Destination:").replace("'","")
			if not os.path.exists(config.copy_dst):
				print("Path does not exist. Try again.")
			else:
				break
		while True:
			if os.path.exists(config.music_lib):
				print('Music library path: {}'.format(config.music_lib))
				if input('Use default? [Y/N]').upper() == 'Y':
					break
			else:	
				config.music_lib = input('Music library path' +
					'(optional):').replace("'","")
				if not os.path.exists(config.music_lib):
					# Make sure the playlist just entered exists
					print('Path does not exist, continue anyway?', 
						end=' ')
					if input("[Y/N]").upper() == 'N':
						continue
				break
		print("[Press enter and continue when there are no more " + 
		"playlists to add]")
		while True:
			playlists.append(input("Path to Playlist:").replace("'",""))
			if not os.path.exists(playlists[len(playlists)-1]):
				# Make sure the playlist just entered exists
				print('File does not exist, continue anyway?', end=' ')
				playlists.pop()
				if input("[Y/N]").upper() == 'Y':
					break
		verbose = True	# Default to verbose on interactive
	
	if auto_gen == True:
		generate_playlist(
			fetch_lib(config.player_lib), 
			config.autogen_pl,
			config.r_cutoff)
	
	if playlists != []:
		for path in playlists:
			try:
				playlist = load(path)
				export(playlist, 
					config.copy_dst, 
					config.music_lib, 
					verbose)
			except FileNotFoundError:
				report(error_log, "Playlist @ {} not found!"
					.format(path))
				break
			except NotSupportedError:
				report(error_log, "Playlist @ " + path + " is not" +
					" a supported file type!")
				break
	else:
		report(error_log, "No playlists passed!")
