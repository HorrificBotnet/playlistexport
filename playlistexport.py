#!/usr/bin/env python3

'''Copy a playlist while retaining the directory hierarchy'''

#TODO:
#-Allow transfering a folder full of playlists automatically
#-Allow option to transfer playlist with the songs
#-Convert playlists from windows to unix, old library to new, etc.
#-Make locale support for other languages
#-Add file size data to transfer stats (maybe)
#-Fix bug: convert 's so interactive can use 's in file name
#-Add pip packaging and a manfile.

import os, shutil, sys, urllib.parse
from help_dialog import display_help

class NotSupportedError(ValueError): pass

VERSION = '0.3.5'
ERROR_LOG = "error.log"
SETTINGS_PATH = os.path.expanduser('~/.config/playlistexport/config')
ACCEPTED_FILE_TYPES = [".m3u", '.m3u8']
VERBOSE = False

class Settings():
	'''Class used for keeping default settings'''
	path = ''
	player_lib = ''
	music_lib = ''
	copy_dst = ''
	autogen_pl = ''	# Autogen playlist path
	cutoff = 0		# Rating threshold for autogenerating list
	
	def __init__(self, settings_path):
		self.path = settings_path
		self.load()
	
	def save(self):
		with open(self.path, mode='w', encoding='utf-8') as settings:
			settings.write('lib={}\n'.format(self.music_lib))
			settings.write('dst={}\n'.format(self.copy_dst))
			settings.write('gen_lib={}\n'.format(self.player_lib))
			settings.write('gen_dst={}\n'.format(self.autogen_pl))
			settings.write('r={}\n'.format(str(self.cutoff)))
		
	def load(self):
		try:
			with open(self.path, 'r', encoding='utf-8') as settings:
				for line in settings:
					self.parse(line.rstrip())
		except OSError:
			report('Settings file not found, attempting to creating one...', 
				True)
			try:
				os.makedirs(os.path.dirname(SETTINGS_PATH))
			except:
				report('Failed.', True)
			self.save()
		
	def parse(self, setting):
#		POTENTIAL REWRITE CODE, might not be worth it though
#		Ignore for now.
#		for index, char in enumerate(setting):
#			if char == '=':
#				SETTINGS_DICT[setting[:index-1]] = setting[index:]
		if setting[:4] == 'lib=':
			self.music_lib = setting[4:]
		elif setting[:4] == 'dst=':
			self.copy_dst = setting[4:]
		elif setting[:8] == 'gen_lib=':
			self.player_lib = setting[8:]
		elif setting[:8] == 'gen_dst=':
			self.autogen_pl = setting[8:]
		elif setting[:2] == 'r=':
			self.cutoff = int(setting[2:])
	
	def set_defaults(self):
		print('Setting defaults, '+
			'leave blank if manual input preferred...')
		print('(Settings can be manually configured in settings file)')
		self.copy_dst = input('Default transfer destination:')
		self.music_lib = input('Path to music library:')
		self.player_lib = input('Path to gmusicbrowser config file:')
		self.autogen_pl = input('Autogenerated playlist destination:')
		self.cutoff = input('Default rating cutoff (#)?')
		self.save()

def is_accepted_playlist(filename):
	'''Make sure that playlists are an accepted file type.'''
	for t in ACCEPTED_FILE_TYPES:
		if t == os.path.splitext(filename)[1]:
			return True
	return False

def report(m, ERROR=False):
	'''Write to both a log file and the stdout'''
	output = sys.stdout if ERROR == False else sys.stderr
	if VERBOSE: 			# Only write if reporting is turned on
		print(m, file=output)
	if ERROR:				# If error, write to .log as well
		with open(ERROR_LOG, "a") as log:
			log.write(m)
			log.write("\n") # This way we can write more than strings

def load(listpath):
	'''Load the file paths of a playlist into memory'''
	playlist = []
	
	#Check for any exceptions to be handled
	if not os.path.isfile(listpath):
		raise FileNotFoundError("Playlist @ {} file not found.".format(
			listpath))
	
	if not is_accepted_playlist(listpath):
		raise NotSupportedError("File type not supported.")
	
	with open(listpath, "r", encoding="utf-8") as f: # loads a .m3u file
		for path in f:
			if path[0] == "#" or path[0] == '\n':
				continue	# Ignore comments and white space
			playlist.append(path.rstrip())	#Get rid of \n on paths
	
	return playlist

def fetch_lib(config_dir):
	'''Fetch music library data (gmusicbrowser only so far)'''
	songs = []				#All data about songs from config gmb
	songs_reached = False	#Bool to check when we reach  [songs]
	gmb_data_seq = (		#Order that gmb song list is tabbed
		'index',			#To be zip()'d into a dictionary w/results
		'added',
		'album',
		'album_artist_raw',
		'artist',	
		'bitrate',	
		'channel',
		'comment',	
		'compilation',	
		'disc',
		'file',
		'filetype',
		'genre',	
		'grouping',
		'label',
		'lastplay',
		'lastskip',	
		'length',
		'length_estimated',
		'missing',
		'modif',
		'path',
		'playcount',
		'playhistory',	
		'rating',
		'replaygain_album_gain',
		'replaygain_album_peak',
		'replaygain_track_gain',	
		'replaygain_track_peak',
		'samprate',
		'size',
		'skipcount',
		'title',	
		'track',
		'version',
		'year'
	)
	
	#Check for any exceptions to be handled
	if not os.path.isfile(config_dir):
		raise FileNotFoundError("GMusicbrowser config file not found.")
		
	with open(config_dir, 'r', encoding='utf-8') as conf:
		# For parsing a gmusicbrowser library
		for entry in conf:
			if entry.rstrip() == '[album]':	
				songs.pop() #last entry is garbage
				break	# Break once we're out of [Songs]
			if entry.rstrip() == '[Songs]':
				songs_reached = True
				continue
			if songs_reached == False:
				continue
			elif songs_reached == True:
				tabbed_list = entry.rstrip().split('\t')
				if tabbed_list[0] == "added" or tabbed_list[0] == '':
					#skip any lines that aren't an entry
					continue 
				else:
					song = dict(zip(gmb_data_seq, tabbed_list))
					song['path'] = urllib.parse.unquote(song['path'])
					song['file'] = urllib.parse.unquote(song['file'])
					songs.append(song)
	
	return songs
				
def generate_playlist(songs_list, destination, rating=0):
	'''Generate a playlist based on music library data'''
	
	with open(destination, 'w', encoding='utf-8') as f:
		f.write('#EXTM3U\n\n')	# Heading for an m3u file
		for song in songs_list:
			if song['rating'] == '':
				song['rating'] = 0	# '' is invalid for int()
			if int(song['rating']) > rating: 
				f.write('#EXTINF:{},{} - {}\n'.format(
					song['length'],
					song['artist'], 
					song['title']))
				f.write('{}\n'.format(os.path.join(
					song['path'], 
					song['file'])))
	f.close()

def export(playlist, dst_root, src_root=''):
	'''Export playlist file paths while maintaining dir hierarchy'''
	for list_index, path in enumerate(playlist):
		if os.path.isabs(path) == False:
			# Assume music dir as root if paths are relative
			path = os.path.join(src_root, path)
		filename = os.path.basename(path)  # Seperate filename from path
		# add 1 to len(src_root) so if src_root is '' it still works
		dst_dirs = os.path.join(dst_root, 
			path[len(src_root)+1:-len(filename)])
		full_dst = os.path.join(dst_dirs, filename)
		
		if VERBOSE == True:
			os.system('cls' if os.name == 'nt' else 'clear')
		
		report("{0} of {1} songs...".format(list_index+1,len(playlist)))
		
		if not os.path.isdir(dst_dirs):
			report("Making directory {0}...".format(dst_dirs),)
			try:
				os.makedirs(dst_dirs)
			except OSError as e:
				report("UNABLE TO MAKE DIRECTORY!", True)
				report('OS Error:{}'.format(e), True)
		
		try:
			src_file_mod = os.stat(path).st_mtime
			dst_file_mod = os.stat(full_dst).st_mtime	
		except FileNotFoundError:	# Assume dst file does not exist
			src_file_mod = 1		# Deal with later if src doesn't
			dst_file_mod = 0
		
		if src_file_mod > dst_file_mod:	# Only replace if modified
			try:
				report("Copying {0}...".format(filename))
				shutil.copy(path, full_dst)
			except FileNotFoundError:	# Src file not found
				report("Skipping {0}, does not exist!".format(filename),
					True)

if __name__ == "__main__":
	playlists = []
	config = Settings(SETTINGS_PATH)
	auto_gen = False
	
	if len(sys.argv) > 1:	# If there are args, read them.
		for a in sys.argv:
			if a[0] == "-":
				for flag in a:
					if flag == 'h':
						display_help()
						exit()
					if flag == 'v':
						VERBOSE = True
					if flag == 'a':
						auto_gen = True
					if flag == 'd':
						config.set_defaults()
						exit()
			if is_accepted_playlist(a):
				playlists.append(a)
			config.parse(a)
	else:	# Prompt the user directly for files
		print("Must use absolute file paths, do not end with / or \\.")
		while True:
			if os.path.isdir(config.copy_dst):
				print('Destination: {}'.format(config.copy_dst))
				if input('Use default? [Y/N]').upper() == 'Y':
					break
			config.copy_dst = input("Destination:").strip('\'')
			if not os.path.isdir(config.copy_dst):
				print("Path does not exist.")
				if input("Make path? [Y/N]").upper() == 'N':
					continue
				else:
					try:
						os.makedirs(config.copy_dst)
					except OSError as e:
						report("UNABLE TO MAKE DIRECTORY!", True)
						report('OS Error:{}'.format(e), True)
						exit()
					break
			else:
				break
		while True:
			if os.path.isdir(config.music_lib):
				print('Music library path: {}'.format(config.music_lib))
				if input('Use default? [Y/N]').upper() == 'Y':
					break
				else:
					config.music_lib = ''
			else:	
				config.music_lib = input('Music library path' +
					'(optional):').strip('\'')
				if not os.path.isdir(config.music_lib):
					# Make sure the playlist just entered exists
					print('Path does not exist, continue anyway?', 
						end=' ')
					if input("[Y/N]").upper() == 'N':
						continue
				break
		print("[Press enter and continue when there are no more " + 
		"playlists to add]")
		while True:
			playlists.append(input("Path to Playlist:").strip('\''))
			if not os.path.isfile(playlists[len(playlists)-1]):
				# Make sure the playlist just entered exists
				print('File does not exist, continue anyway?', end=' ')
				playlists.pop()
				if input("[Y/N]").upper() == 'Y':
					break
		VERBOSE = True	# Default to VERBOSE on interactive
	
	if auto_gen == True:
		generate_playlist(
			fetch_lib(config.player_lib), 
			config.autogen_pl,
			config.cutoff)
	
	if playlists != []:
		for path in playlists:
			try:
				playlist = load(path)
				export(playlist, 
					config.copy_dst, 
					config.music_lib)
			except FileNotFoundError as e:
				report("Playlist @ {} not found!".format(path), True)
				report('FileNotFound: {}'.format(e), True)
				break
			except NotSupportedError:
				report("Playlist @ " + path + " is not" +
					" a supported file type!", True)
				break
	else:
		report("No playlist(s) passed!", True)
